<html>
<head>
<script src="https://code.jquery.com/jquery-3.2.1.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>
<style>
canvas {
    border-style: solid;
    border-color: black;
    border-width: 1px;
}
</style>
</head>
<body>
<canvas id="truth" width="200px" height="200px"></canvas>
<br/>
<canvas id="network" width="200px" height="200px"></canvas>
<br/>
<canvas id="network21" width="200px" height="200px"></canvas>
<canvas id="network22" width="200px" height="200px"></canvas>
<canvas id="network23" width="200px" height="200px"></canvas>
<canvas id="network24" width="200px" height="200px"></canvas>
<br/>
<canvas id="network3" width="200px" height="200px"></canvas>
<br/>
<canvas id="output" width="200px" height="200px"></canvas>
<div id="network-vis"></div>
<br/>
Iteration: <label id="iteration">0</label>
<br/>
Classified wrong: <label id="error">NaN</label>%
<br/>
<input id="learnRate" type="number" value="0.03" step="0.02"/>
<input id="playpause" type="button" value="Play/Pause" />
<script>

function indexOfMax(arr) {
    if (arr.length === 0) {
        return -1;
    }

    var max = arr[0];
    var maxIndex = 0;

    for (var i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            maxIndex = i;
            max = arr[i];
        }
    }

    return maxIndex;
}

function shuffle(a) {
    for (let i = a.length; i; i--) {
        let j = Math.floor(Math.random() * i);
        [a[i - 1], a[j]] = [a[j], a[i - 1]];
    }
}

function Sigmoid() {
    this.lastValue = NaN;
}

Sigmoid.prototype.value = function(x) {
    this.lastValue = 1 / (1 + Math.exp(-x));
    return this.lastValue;
}

Sigmoid.prototype.derivative = function(x) {
    let value = (typeof x !== 'undefined') ? this.value(x) : this.lastValue;
    return value * (1 - value);
}

function Neuron(inputSize, func) {
    this.func = func || new Sigmoid();
    this.weights = [];
    for (var i = 0; i < inputSize; ++i) {
        this.weights.push(5*Math.random()-2.5);
        if (this.weights[i] == 0)
            --i;
//         this.weights.push(Math.random());
//         this.weights.push(1);
    }
}

Neuron.prototype.weightedInputSum = function(input) {
    if (input.length != this.weights.length) {
        throw TypeError;
    }
    var sum = 0;
    for (var i = 0; i < this.weights.length; ++i) {
        sum += this.weights[i] * input[i];
    }
    return sum;
}

Neuron.prototype.value = function(input) {
    return this.func.value(this.weightedInputSum(input));
}

Neuron.prototype.errorGradient = function(error, input) {
    return error * this.func.derivative(input && this.weightedInputSum(input));
}

Neuron.prototype.adjustWeights = function(learnRate, error, input, useCached) {
    let errGradient = this.errorGradient(error, (useCached ? undefined : input));
    for (var i = 0; i < this.weights.length; ++i) {
        this.weights[i] += -1 * learnRate * errGradient * input[i];
    }
}

function NeuronVisualizer(neuron) {
    this.neuron = neuron;
    this.dom = $('<div></div>');
    this.weights = $('<ol></ol>').appendTo(this.dom);
    this.neuron.weights.forEach(function(w) { $('<li></li>').appendTo(this.weights).text(w); }.bind(this));
    this.error = $('<span></span>').appendTo(this.dom).text(NaN);
    this.value = $('<span></span>').appendTo(this.dom).text(this.neuron.func.lastValue);
}

NeuronVisualizer.prototype.update = function(error) {
    $('ol li', this.dom).text(function(i) {
        return this.neuron.weights[i];
    }.bind(this));
    this.value.text(this.neuron.func.lastValue);
    if (typeof error !== 'undefined') {
        this.error.text(error);
    }
}

function Layer(size, neuronClass) {
    this.neurons = [];
    for (var i = 0; i < size; ++i) {
        this.neurons.push(new neuronClass());
    }
}

Layer.prototype.value = function(input) {
    var output = [];
    for (var i = 0; i < this.neurons.length; ++i) {
        output.push(this.neurons[i].value(input));
    }
    return output;
}

Layer.prototype.inputError = function(errors, input, useCached) {
    useCached = useCached === true;
    var inputErrors = [];
    for (var j = 0; j < input.length; ++j) {
        inputErrors.push(0);
    }
    for (var i = 0; i < this.neurons.length; ++i) {
        var errorGradient = this.neurons[i].errorGradient(errors[i], (useCached ? undefined : input));
        for (var j = 0; j < input.length; ++j) {
            inputErrors[j] += errorGradient * this.neurons[i].weights[j];
        }
    }
    return inputErrors;
}

Layer.prototype.correctErrors = function(learningRate, errors, input, useCached) {
    useCached = useCached === true;
    for (var i = 0; i < this.neurons.length; ++i) {
        this.neurons[i].adjustWeights(learningRate, errors[i], input, useCached);
    }
}

function LayerVisualizer(layer) {
    this.layer = layer;
    this.neuronsVisualizers = this.layer.neurons.map(function(n) { return new NeuronVisualizer(n); });
    this.dom = $('<div></div>');
    this.neurons = $('<ol></ol>').appendTo(this.dom);
    this.neuronsVisualizers.forEach(function(nv) {
        nv.dom.appendTo(this.neurons);
    }.bind(this));
}

LayerVisualizer.prototype.update = function(errors) {
    for (var i = 0; i < this.neuronsVisualizers.length; ++i) {
        this.neuronsVisualizers[i].update(errors[i]);
    }
}

function paintPlot(canvas, xy, classes, clearCavas, xi, yi, bw) {
    clearCavas = clearCavas !== false;
    bw = bw === true;
    xi = (typeof xi !== 'undefined') ? xi : 0;
    yi = (typeof yi !== 'undefined') ? yi : 1;

    var margin = 0;

    var maxClass = Math.max.apply(null, classes);
    var context = canvas.getContext('2d');
    if (clearCavas)
        context.clearRect(0, 0, canvas.width, canvas.height);
    for (var i = 0; i < xy.length; ++i) {
        if (bw)
            context.fillStyle = 'hsl(0, 0%,' + (classes[i] * (100/(maxClass))) + '%)';
        else
            context.fillStyle = 'hsl(' + (classes[i] * (360/(maxClass+1))) + ', 100%,50%)';
        context.beginPath();
        var x = margin + (xy[i][xi] * (canvas.width - 2*margin));
        var y = margin + ((1 - xy[i][yi]) * (canvas.height - 2*margin));
        context.arc(x, y, 2, 0, 2 * Math.PI);
        context.strokeStyle = "black";
        context.stroke();
        context.fill();
    }
}

function visualizeNetwork(canvas, network, clearCavas) {
    clearCavas = clearCavas !== false;

    var margin = 0;

    var pointsPerAxis = 10;
    var intervals = pointsPerAxis-1;
    var step = 1 / intervals;
    //var input = [];
    var output = [];
    //var flatOutput = [];
    for (var i = 0; i < pointsPerAxis; ++i) {
        var row = [];
        for (var j = 0; j < pointsPerAxis; ++j) {
            //input.push([step * j, step * i]);
            let value = network.value([step * j, step * i]);
            //flatOutput.push(value);
            row.push(value);
        }
        output.push(row);
    }
    var context = canvas.getContext('2d');
    if (clearCavas)
        context.clearRect(0, 0, canvas.width, canvas.height);

    var scaleY = canvas.height / (intervals);
    var scaleX = canvas.width / (intervals);
    for (var y = 0; y < canvas.height; ++y) {
        var iyv = y / scaleY;
        var iy0 = Math.floor(iyv);
        var iy1 = Math.ceil(iyv);
        for (var x = 0; x < canvas.width; ++x) {
            var ixv = x / scaleX;
            var ix0 = Math.floor(ixv);
            var ix1 = Math.ceil(ixv);

            var el00 = output[iy0][ix0];
            var el10 = output[iy1][ix0];
            var el01 = output[iy0][ix1];
            var el11 = output[iy1][ix1];

            var dx = ixv - ix0;
            var dy = iyv - iy0;

            function inner(f00, f10, f01, f11, x, y) {
                var un_x = 1.0 - x; var un_y = 1.0 - y;
                return (f00 * un_x * un_y + f10 * x * un_y + f01 * un_x * y + f11 * x * y);
            }

            var inter = [];
            for (var k = 0; k < el00.length; ++k) {
                inter.push(inner(el00[k], el10[k], el01[k], el11[k], dy, dx));
            }

            context.fillStyle = 'hsl(' + (indexOfMax(inter) * (360/(inter.length))) + ', 100%,50%)';
            // TODO: it's flipped, either vertically or horizontally
            context.fillRect(x, canvas.height - 1 - y, 1, 1);
        }
    }

    //paintPlot(canvas, input, flatOutput.map(function(x) { return indexOfMax(x); }), false,  0, 1, true);
}

(function() {

var rateInput = document.getElementById('learnRate');
var rate = rateInput.value;
rateInput.addEventListener('change', function(x) {
    rate = rateInput.value;
    console.log("new rate " + rate);
});

var errorLabel = document.getElementById('error');
var iterationLabel = document.getElementById('iteration');

var trainData = 200;
let numberOfClasses = 2;
var l = new Layer(2, Neuron.bind(null, 2));
var l2 = new Layer(4, Neuron.bind(null, 3));
var l3 = new Layer(numberOfClasses, Neuron.bind(null, 5));
var net = {
    value: function(input) {
        return l3.value(l2.value(l.value(input).concat([1])).concat([1]));
    }
}

var lv = new LayerVisualizer(l);
var lv2 = new LayerVisualizer(l2);
var lv3 = new LayerVisualizer(l3);

$('#network-vis').append(lv.dom).append(lv2.dom).append(lv3.dom);

var original = [];
var classes = [];

function pointInRing(radius, width) {
//     var radius = 0.8;
    var spanWidth = width;
    var span = Math.random() / (1/spanWidth) - spanWidth/2;
    var angle = Math.random()*Math.PI*2;
    x = (0.5 + Math.cos(angle)*(radius + span));
    y = (0.5 + Math.sin(angle)*(radius + span));
    return [x, y];
}

for (var i = 0; i < trainData; ++i) {
    var pClass = Math.floor(Math.random() * numberOfClasses);
    var x = 0, y = 0;
    if (!pClass) {
//         x = 0.3 + Math.random()/3;
//         y = 0.3 + Math.random()/3;
        var point = pointInRing(0.125, 0.25);
        x = point[0];
        y = point[1];
    } else {
        var point = pointInRing(0.425, 0.15);
        x = point[0];
        y = point[1];
    }
    original.push([x, y]);
    classes.push(pClass);
}
var currentIteration = 0;
var stop = true;
var itOrder = original.map(function(x, i) { return i; });
function go() {
    var j = currentIteration++;
//     if (j >= 10000) {
//         return;
//     }

    var output = [];
    var output2 = [];
    var output3 = [];
    var avgError = 0;

    var batchSize = 10;
    var good = [];
    //shuffle(itOrder);
    for (var i = 0; i < itOrder.length; ++i) {
        let input = original[itOrder[i]];
        let tClass = classes[itOrder[i]];
        let netOuput = [];
        netOuput.push(l.value(input).concat([1]));
        netOuput.push(l2.value(netOuput[0]).concat([1]));
        netOuput.push(l3.value(netOuput[1]));


        let choosenClass = indexOfMax(netOuput[2]);
        let errors = netOuput[2].map(function(x, i) {
            if (i == tClass)
                return x - 1;
            return x - 0;
        });
        /*
        if (tClass > 0.5) {
            error[0] += netOuput[2][0] - 0;
            error[1] += netOuput[2][1] - 1;
        } else {
            error[0] += netOuput[2][0] - 1;
            error[1] += netOuput[2][1] - 0;
        }
        */
        /*
        if ((1 + i%batchSize) == batchSize) {
            error = error.map(function(x){return x / batchSize;});


            error = [0, 0];
        }
        */

//         var error = (output3[i] - classes[i]);
//         var error = (output3[i] > 0.5) == (classes[i] > 0.5);
//         avgError += error * error;
        //avgError += (netOuput[2][1] > netOuput[2][0]) != (tClass > 0.5);
        avgError += choosenClass != tClass;
        var l2Errors = l3.inputError(errors, netOuput[1], true);
        var l1Errors = l2.inputError(l2Errors, netOuput[0], true);
        l3.correctErrors(rate, errors, netOuput[1], true);
        l2.correctErrors(rate, l2Errors, netOuput[0], true);
        l.correctErrors(rate, l1Errors, input, true);

        lv.update(l1Errors);
        lv2.update(l2Errors);
        lv3.update(errors);

        good[itOrder[i]] = choosenClass == tClass;
        output[itOrder[i]] = (netOuput[0]);
        output2[itOrder[i]] = (netOuput[1]);
        output3[itOrder[i]] = (netOuput[2]);
    }
    avgError /= trainData;
    errorLabel.innerHTML = avgError * 100;
    iterationLabel.innerHTML = j;

//     console.log("Iteration " + j + " error " + avgError);

    paintPlot(document.getElementById('truth'), original, classes);
    paintPlot(document.getElementById('network'), output, classes);
    paintPlot(document.getElementById('network21'), output2, classes, true, 0, 1);
    paintPlot(document.getElementById('network22'), output2, classes, true, 1, 2);
    paintPlot(document.getElementById('network23'), output2, classes, true, 2, 3);
    paintPlot(document.getElementById('network24'), output2, classes, true, 3, 0);
    paintPlot(document.getElementById('network3'), output3, classes);


    visualizeNetwork(document.getElementById('output'), net);
    paintPlot(document.getElementById('output'), original, good, false, 0, 1, true);

    if (!stop)
        window.setTimeout(go.bind(this), 0);
};

// go once
go();

document.getElementById('playpause').onclick = function() {
    stop = !stop;
    if (!stop) {
        go()
    }
}
})();
</script>
</body>
<html>

