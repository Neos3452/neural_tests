<html>
<head>
<style>
canvas {
    border-style: solid;
    border-color: black;
    border-width: 1px;
}
</style>
</head>
<body>
<canvas id="truth" width="200px" height="200px"></canvas>
<canvas id="network" width="200px" height="200px"></canvas>
<canvas id="network2" width="200px" height="200px"></canvas>
<br/>
Iteration: <label id="iteration">0</label>
<br/>
Classified wrong: <label id="error">NaN</label>%
<br/>
<input id="learnRate" type="number" value="0.03" step="0.02"/>
<input id="playpause" type="button" value="Play/Pause" />
<script>
function Sigmoid() {
}

Sigmoid.prototype.value = function(x) {
    return 1 / (1 + Math.exp(-x));
}

Sigmoid.prototype.derivative = function(x) {
    let value = this.value(x);
    return value * (1 - value);
}

function Neuron(inputSize, func) {
    this.func = func || new Sigmoid();
//     this.lastValue = 0;
    this.weights = [];
    for (var i = 0; i < inputSize; ++i) {
        this.weights.push(10*Math.random()-5);
//         this.weights.push(Math.random());
//         this.weights.push(1);
    }
}

Neuron.prototype.weightedInputSum = function(input) {
    if (input.length != this.weights.length) {
        throw TypeError;
    }
    var sum = 0;
    for (var i = 0; i < this.weights.length; ++i) {
        sum += this.weights[i] * input[i];
    }
    return sum;
}

Neuron.prototype.value = function(input) {
    return this.func.value(this.weightedInputSum(input));
}

Neuron.prototype.errorGradient = function(input, error) {
    return error * this.func.derivative(this.weightedInputSum(input));
}

Neuron.prototype.adjustWeights = function(input, error, learnRate) {
    let errGradient = this.errorGradient(input, error);
    for (var i = 0; i < this.weights.length; ++i) {
        this.weights[i] += -1 * learnRate * errGradient * input[i];
    }
}

function Layer(size, neuronClass) {
    this.neurons = [];
    for (var i = 0; i < size; ++i) {
        this.neurons.push(new neuronClass());
    }
}

Layer.prototype.value = function(input) {
    var output = [];
    for (var i = 0; i < this.neurons.length; ++i) {
        output.push(this.neurons[i].value(input));
    }
    return output;
}

Layer.prototype.inputError = function(input, errors) {
    var inputErrors = [];
    for (var j = 0; j < input.length; ++j) {
        inputErrors.push(0);
    }
    for (var i = 0; i < this.neurons.length; ++i) {
        var errorGradient = this.neurons[i].errorGradient(input, errors[i]);
        for (var j = 0; j < input.length; ++j) {
            inputErrors[j] += errorGradient * this.neurons[i].weights[j];
        }
    }
    return inputErrors;
}

Layer.prototype.correctErrors = function(input, errors, learningRate) {
    for (var i = 0; i < this.neurons.length; ++i) {
        this.neurons[i].adjustWeights(input, errors[i], learningRate);
    }
}

function paintPlot(canvas, xy, classes) {

    var margin = 5;

    var maxClass = Math.max.apply(null, classes);
//     var maxInput = Math.max.apply(null, input);
//     var minInput = Math.min.apply(null, input);
//     var inputStep = (canvas.width - 2*margin) / (maxInput - minInput);
//     var inputStep = (canvas.width - 2*margin) / input.length;
//     var maxOutput = Math.max.apply(null, output);
//     var minOutput = Math.min.apply(null, output);
//     var outputStep = (canvas.height - 2*margin) / (maxOutput - minOutput);
//     var outputStep = (canvas.height - 2*margin) / output.length;
    var context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
    for (var i = 0; i < xy.length; ++i) {
        context.fillStyle = 'hsl(' + (classes[i] * (360/(maxClass+1))) + ', 100%,50%)';
        context.beginPath();
//         var x = margin + input[i] * inputStep;
//         var y = margin + output[i] * outputStep;
        var x = margin + (xy[i][0] * (canvas.width - 2*margin));
        var y = margin + ((1 - xy[i][1]) * (canvas.height - 2*margin));
        context.arc(x, y, 3, 0, 2 * Math.PI);
        context.fill();
    }
}

(function() {

var rateInput = document.getElementById('learnRate');
var rate = rateInput.value;
rateInput.addEventListener('change', function(x) {
    rate = rateInput.value;
    console.log("new rate " + rate);
});

var errorLabel = document.getElementById('error');
var iterationLabel = document.getElementById('iteration');

var trainData = 200;
var l = new Layer(2, Neuron.bind(null, 2));
var l2 = new Layer(6, Neuron.bind(null, 3));
var l3 = new Layer(2, Neuron.bind(null, 7));
var original = [];
var classes = [];

function pointInRing(radius, width) {
//     var radius = 0.8;
    var spanWidth = width;
    var span = Math.random() / (1/spanWidth) - spanWidth/2;
    var angle = Math.random()*Math.PI*2;
    x = (0.5 + Math.cos(angle)*(radius + span));
    y = (0.5 + Math.sin(angle)*(radius + span));
    return [x, y];
}

for (var i = 0; i < trainData; ++i) {
    var pClass = Math.floor(Math.random() * 2);
    var x = 0, y = 0;
    if (pClass) {
//         x = 0.3 + Math.random()/3;
//         y = 0.3 + Math.random()/3;
        var point = pointInRing(0.15, 0.3);
        x = point[0];
        y = point[1];
    } else {
        var point = pointInRing(0.5, 0.2);
        x = point[0];
        y = point[1];
    }
    original.push([x, y]);
    classes.push(pClass);
}
var currentIteration = 0;
var stop = true;
function go() {
    var j = currentIteration++;
//     if (j >= 10000) {
//         return;
//     }

    var output = [];
    var output2 = [];
    var output3 = [];
    var avgError = 0;
    for (var i = 0; i < trainData; ++i) {
        output.push(l.value(original[i]).concat([1]));
        output2.push(l2.value(output[i]).concat([1]));
        output3.push(l3.value(output2[i]));

        var error = [0, 0];
        if (classes[i] > 0.5) {
            error[0] = output3[i][0] - 0;
            error[1] = output3[i][1] - 1;
        } else {
            error[0] = output3[i][0] - 1;
            error[1] = output3[i][1] - 0;
        }
//         var error = (output3[i] - classes[i]);
//         var error = (output3[i] > 0.5) == (classes[i] > 0.5);
//         avgError += error * error;
        avgError += (output3[i][1] > output3[i][0]) != (classes[i] > 0.5);
        var errors = error;
        var l2Errors = l3.inputError(output2[i], errors);
        var l1Errors = l2.inputError(output[i], l2Errors);
        l3.correctErrors(output2[i], errors, rate);
        l2.correctErrors(output[i], l2Errors, rate);
        l.correctErrors(original[i], l1Errors, rate);
    }
    avgError /= trainData;
    errorLabel.innerHTML = avgError * 100;
    iterationLabel.innerHTML = j;

//     console.log("Iteration " + j + " error " + avgError);

    paintPlot(document.getElementById('truth'), original, classes);
    paintPlot(document.getElementById('network'), output, classes);
    paintPlot(document.getElementById('network2'), output2, classes);

    if (!stop)
        window.setTimeout(go.bind(this), 0);
};

// go once
go();

document.getElementById('playpause').onclick = function() {
    stop = !stop;
    if (!stop) {
        go()
    }
}
})();
</script>
</body>
<html>

